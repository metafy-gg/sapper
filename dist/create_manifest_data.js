'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _commonjsHelpers = require('./_commonjsHelpers.js');
var path = require('path');
var path__default = _interopDefault(path);
var fs = require('fs');
var module$1 = _interopDefault(require('module'));
var index = require('./index.js');
var hash = _interopDefault(require('string-hash'));
var codec = require('sourcemap-codec');
var env = require('./env.js');

function create_app(_a) {
    var bundler = _a.bundler, manifest_data = _a.manifest_data, dev_port = _a.dev_port, dev = _a.dev, cwd = _a.cwd, src = _a.src, dest = _a.dest, routes = _a.routes, output = _a.output;
    if (!fs.existsSync(output))
        fs.mkdirSync(output);
    var path_to_routes = path.relative(output + "/internal", routes);
    var client_manifest = generate_client_manifest(manifest_data, path_to_routes, bundler, dev, dev_port);
    var server_manifest = generate_server_manifest(manifest_data, path_to_routes, cwd, src, dest, dev);
    var app = generate_app(manifest_data, path_to_routes);
    _commonjsHelpers.write_if_changed(output + "/internal/manifest-client.mjs", client_manifest);
    _commonjsHelpers.write_if_changed(output + "/internal/manifest-server.mjs", server_manifest);
    _commonjsHelpers.write_if_changed(output + "/internal/App.svelte", app);
}
function create_serviceworker_manifest(_a) {
    var manifest_data = _a.manifest_data, output = _a.output, client_files = _a.client_files, static_files = _a.static_files;
    var files = ['service-worker-index.html'];
    if (fs.existsSync(static_files)) {
        files = files.concat(_commonjsHelpers.walk(static_files));
    }
    else {
        // TODO remove in a future version
        if (fs.existsSync('assets')) {
            throw new Error("As of Sapper 0.21, the assets/ directory should become static/");
        }
    }
    var code = ("\n\t\t// This file is generated by Sapper \u2014 do not edit it!\n\t\texport const timestamp = " + Date.now() + ";\n\n\t\texport const files = [\n\t" + files.map(function (x) { return _commonjsHelpers.stringify('/' + x); }).join(',\n\t') + "\n];\n\t\texport { files as assets }; // legacy\n\n\t\texport const shell = [\n\t" + client_files.map(function (x) { return _commonjsHelpers.stringify('/' + x); }).join(',\n\t') + "\n];\n\n\t\texport const routes = [\n\t" + manifest_data.pages.map(function (r) { return "{ pattern: " + r.pattern + " }"; }).join(',\n\t') + "\n];\n\t").replace(/^\t\t/gm, '').trim();
    _commonjsHelpers.write_if_changed(output + "/service-worker.js", code);
}
function create_param_match(param, i) {
    return /^\.{3}.+$/.test(param)
        ? param.replace(/.{3}/, '') + ": d(match[" + (i + 1) + "]).split('/')"
        : param + ": d(match[" + (i + 1) + "])";
}
function generate_client_manifest(manifest_data, path_to_routes, bundler, dev, dev_port) {
    var page_ids = new Set(manifest_data.pages.map(function (page) {
        return page.pattern.toString();
    }));
    var server_routes_to_ignore = manifest_data.server_routes.filter(function (route) {
        return !page_ids.has(route.pattern.toString());
    });
    var component_indexes = {};
    var components = ("[\n\t\t" + manifest_data.components.map(function (component, i) {
        var annotation = bundler === 'webpack'
            ? "/* webpackChunkName: \"" + component.name + "\" */ "
            : '';
        var source = get_file(path_to_routes, component);
        component_indexes[component.name] = i;
        return "{\n\t\t\t\t\tjs: () => import(" + annotation + _commonjsHelpers.stringify(source) + "),\n\t\t\t\t\tcss: \"__SAPPER_CSS_PLACEHOLDER:" + _commonjsHelpers.stringify(component.file, false) + "__\"\n\t\t\t\t}";
    }).join(',\n\t\t\t\t') + "\n\t]").replace(/^\t/gm, '');
    var needs_decode = false;
    var routes = ("[\n\t\t\t\t" + manifest_data.pages.map(function (page) { return "{\n\t\t\t\t\t// " + page.parts[page.parts.length - 1].component.file + "\n\t\t\t\t\tpattern: " + page.pattern + ",\n\t\t\t\t\tparts: [\n\t\t\t\t\t\t" + page.parts.map(function (part) {
        var missing_layout = !part;
        if (missing_layout)
            return 'null';
        if (part.params.length > 0) {
            needs_decode = true;
            var props = part.params.map(create_param_match);
            return "{ i: " + component_indexes[part.component.name] + ", params: match => ({ " + props.join(', ') + " }) }";
        }
        return "{ i: " + component_indexes[part.component.name] + " }";
    }).join(',\n\t\t\t\t\t\t') + "\n\t\t\t\t\t]\n\t\t\t\t}"; }).join(',\n\n\t\t\t\t') + "\n\t]").replace(/^\t/gm, '');
    if (needs_decode) {
        routes = "(d => " + routes + ")(decodeURIComponent)";
    }
    return ("\n\t\t// This file is generated by Sapper \u2014 do not edit it!\n\t\t// webpack does not support export * as root_comp yet so do a two line import/export\n\t\timport * as root_comp from '" + _commonjsHelpers.stringify(get_file(path_to_routes, manifest_data.root), false) + "';\n\t\texport { root_comp };\n\t\texport { default as ErrorComponent } from '" + _commonjsHelpers.stringify(get_file(path_to_routes, manifest_data.error), false) + "';\n\n\t\texport const ignore = [" + server_routes_to_ignore.map(function (route) { return route.pattern; }).join(', ') + "];\n\n\t\texport const components = " + components + ";\n\n\t\texport const routes = " + routes + ";\n\n\t\t" + (dev ? "if (typeof window !== 'undefined') {\n\t\t\timport(" + _commonjsHelpers.stringify(_commonjsHelpers.posixify(path.resolve(__dirname, '../sapper-dev-client.js'))) + ").then(client => {\n\t\t\t\tclient.connect(" + dev_port + ");\n\t\t\t});\n\t\t}" : '') + "\n\t").replace(/^\t{2}/gm, '').trim();
}
function generate_server_manifest(manifest_data, path_to_routes, cwd, src, dest, dev) {
    var imports = [].concat(manifest_data.server_routes.map(function (route, i) {
        return "import * as route_" + i + " from " + _commonjsHelpers.stringify(_commonjsHelpers.posixify(path_to_routes + "/" + route.file)) + ";";
    }), manifest_data.components.map(function (component, i) {
        return "import * as component_" + i + " from " + _commonjsHelpers.stringify(get_file(path_to_routes, component)) + ";";
    }), "import * as root_comp from " + _commonjsHelpers.stringify(get_file(path_to_routes, manifest_data.root)) + ";", "import error from " + _commonjsHelpers.stringify(get_file(path_to_routes, manifest_data.error)) + ";");
    var component_lookup = {};
    manifest_data.components.forEach(function (component, i) {
        component_lookup[component.name] = i;
    });
    var code = "\n\t\t".replace(/^\t\t/gm, '').trim();
    var build_dir = _commonjsHelpers.posixify(path.normalize(path.relative(cwd, dest)));
    var src_dir = _commonjsHelpers.posixify(path.normalize(path.relative(cwd, src)));
    return ("\n\t\t// This file is generated by Sapper \u2014 do not edit it!\n\t\t" + imports.join('\n') + "\n\n\t\tconst d = decodeURIComponent;\n\n\t\texport const manifest = {\n\t\t\tserver_routes: [\n\t\t\t\t" + manifest_data.server_routes.map(function (route, i) { return "{\n\t\t\t\t\t// " + route.file + "\n\t\t\t\t\tpattern: " + route.pattern + ",\n\t\t\t\t\thandlers: route_" + i + ",\n\t\t\t\t\tparams: " + (route.params.length > 0
        ? "match => ({ " + route.params.map(create_param_match).join(', ') + " })"
        : "() => ({})") + "\n\t\t\t\t}"; }).join(',\n\n\t\t\t\t') + "\n\t\t\t],\n\n\t\t\tpages: [\n\t\t\t\t" + manifest_data.pages.map(function (page) { return "{\n\t\t\t\t\t// " + page.parts[page.parts.length - 1].component.file + "\n\t\t\t\t\tpattern: " + page.pattern + ",\n\t\t\t\t\tparts: [\n\t\t\t\t\t\t" + page.parts.map(function (part) {
        if (part === null)
            return 'null';
        var props = [
            "name: \"" + part.component.name + "\"",
            "file: " + _commonjsHelpers.stringify(part.component.file),
            "component: component_" + component_lookup[part.component.name]
        ].filter(Boolean);
        if (part.params.length > 0) {
            var params = part.params.map(create_param_match);
            props.push("params: match => ({ " + params.join(', ') + " })");
        }
        return "{ " + props.join(', ') + " }";
    }).join(',\n\t\t\t\t\t\t') + "\n\t\t\t\t\t]\n\t\t\t\t}"; }).join(',\n\n\t\t\t\t') + "\n\t\t\t],\n\n\t\t\troot_comp,\n\t\t\terror\n\t\t};\n\n\t\texport const build_dir = " + JSON.stringify(build_dir) + ";\n\n\t\texport const src_dir = " + JSON.stringify(src_dir) + ";\n\n\t\texport const dev = " + (dev ? 'true' : 'false') + ";\n\t").replace(/^\t{2}/gm, '').trim();
}
function generate_app(manifest_data, path_to_routes) {
    // TODO remove default layout altogether
    var max_depth = Math.max.apply(Math, manifest_data.pages.map(function (page) { return page.parts.filter(Boolean).length; }));
    var levels = [];
    for (var i = 0; i < max_depth; i += 1) {
        levels.push(i + 1);
    }
    var l = max_depth;
    var pyramid = "<svelte:component this=\"{level" + l + ".component}\" {...level" + l + ".props}/>";
    while (l-- > 1) {
        pyramid = ("\n\t\t\t<svelte:component this=\"{level" + l + ".component}\" segment=\"{segments[" + l + "]}\" {...level" + l + ".props}>\n\t\t\t\t{#if level" + (l + 1) + "}\n\t\t\t\t\t" + pyramid.replace(/\n/g, '\n\t\t\t\t\t') + "\n\t\t\t\t{/if}\n\t\t\t</svelte:component>\n\t\t").replace(/^\t\t\t/gm, '').trim();
    }
    return ("\n\t\t<!-- This file is generated by Sapper \u2014 do not edit it! -->\n\t\t<script>\n\t\t\timport { setContext, afterUpdate } from 'svelte';\n\t\t\timport { CONTEXT_KEY } from './shared';\n\t\t\timport Layout from '" + get_file(path_to_routes, manifest_data.root) + "';\n\t\t\timport Error from '" + get_file(path_to_routes, manifest_data.error) + "';\n\n\t\t\texport let stores;\n\t\t\texport let error;\n\t\t\texport let status;\n\t\t\texport let segments;\n\t\t\texport let level0;\n\t\t\t" + levels.map(function (l) { return "export let level" + l + " = null;"; }).join('\n\t\t\t') + "\n\t\t\texport let notify;\n\n\t\t\tafterUpdate(notify);\n\t\t\tsetContext(CONTEXT_KEY, stores);\n\t\t</script>\n\n\t\t<Layout segment=\"{segments[0]}\" {...level0.props}>\n\t\t\t{#if error}\n\t\t\t\t<Error {error} {status}/>\n\t\t\t{:else}\n\t\t\t\t" + pyramid.replace(/\n/g, '\n\t\t\t\t') + "\n\t\t\t{/if}\n\t\t</Layout>\n\t").replace(/^\t\t/gm, '').trim();
}
function get_file(path_to_routes, component) {
    if (component.default)
        return "./" + component.type + ".svelte";
    return _commonjsHelpers.posixify(path_to_routes + "/" + component.file);
}

var modules = {};

var getModule = function(dir) {
  var rootPath = dir ? path__default.resolve(dir) : process.cwd();
  var rootName = path__default.join(rootPath, '@root');
  var root = modules[rootName];
  if (!root) {
    root = new module$1(rootName);
    root.filename = rootName;
    root.paths = module$1._nodeModulePaths(rootPath);
    modules[rootName] = root;
  }
  return root;
};

var requireRelative = function(requested, relativeTo) {
  var root = getModule(relativeTo);
  return root.require(requested);
};

requireRelative.resolve = function(requested, relativeTo) {
  var root = getModule(relativeTo);
  return module$1._resolveFilename(requested, root);
};

var requireRelative_1 = requireRelative;

var dist = _commonjsHelpers.createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
function default_1(chunks) {
    var result = {};
    chunks.filter(function (chunk) { return chunk.facadeModuleId; })
        .forEach(function (chunk) { result[chunk.facadeModuleId] = Array.from(getImports(chunks, [chunk])); });
    return result;
}
exports.default = default_1;
function getImports(allChunks, chunksToResolve) {
    var result = new Set();
    chunksToResolve.forEach(function (chunk) {
        chunk.imports.forEach(function (fileName) {
            if (!result.has(fileName)) { // avoid cycles
                result.add(fileName);
                var importedChunks = allChunks.filter(function (chunk) { return chunk.fileName === fileName; });
                getImports(allChunks, importedChunks).forEach(function (fileName) { return result.add(fileName); });
            }
        });
        result.add(chunk.fileName);
    });
    return result;
}
});

var transitiveDeps = /*@__PURE__*/_commonjsHelpers.unwrapExports(dist);

var inline_sourcemap_header = 'data:application/json;charset=utf-8;base64,';
function extract_sourcemap(raw, id) {
    var raw_map;
    var map = null;
    var code = raw.replace(/\/\*#\s+sourceMappingURL=(.+)\s+\*\//g, function (m, url) {
        if (raw_map) {
            // TODO should not happen!
            throw new Error("Found multiple sourcemaps in single CSS file (" + id + ")");
        }
        raw_map = url;
        return '';
    }).trim();
    if (raw_map) {
        if (raw_map.startsWith(inline_sourcemap_header)) {
            var json = Buffer.from(raw_map.slice(inline_sourcemap_header.length), 'base64').toString();
            map = JSON.parse(json);
        }
    }
    return {
        code: code,
        map: map
    };
}
function get_css_from_modules(modules, css_map, asset_dir) {
    var parts = [];
    var mappings = [];
    var sources = [];
    var sourcesContent = [];
    var names = [];
    modules.forEach(function (module) {
        if (!/\.css$/.test(module))
            return;
        var css = css_map.get(module);
        var _a = extract_sourcemap(css, module), code = _a.code, map = _a.map;
        parts.push(code);
        if (map) {
            var lines = codec.decode(map.mappings);
            if (sources.length > 0 || names.length > 0) {
                lines.forEach(function (line) {
                    line.forEach(function (segment) {
                        // adjust source index
                        segment[1] += sources.length;
                        // adjust name index
                        if (segment[4])
                            segment[4] += names.length;
                    });
                });
            }
            sources.push.apply(sources, map.sources);
            sourcesContent.push.apply(sourcesContent, map.sourcesContent);
            names.push.apply(names, map.names);
            mappings.push.apply(mappings, lines);
        }
    });
    if (parts.length > 0) {
        return {
            code: parts.join('\n'),
            map: {
                version: 3,
                file: null,
                sources: sources.map(function (source) { return path.relative(asset_dir, source).replace(/\\/g, '/'); }),
                sourcesContent: sourcesContent,
                names: names,
                mappings: codec.encode(mappings)
            }
        };
    }
    return null;
}
function extract_css(client_result, components, dirs, sourcemap) {
    var result = {
        main: null,
        chunks: {}
    };
    if (!client_result.css_files)
        return; // Rollup-only for now
    var asset_dir = dirs.dest + "/client";
    if (process.env.SAPPER_LEGACY_BUILD)
        asset_dir += '/legacy';
    var unclaimed = new Set(client_result.css_files.map(function (x) { return x.id; }));
    var lookup = new Map();
    client_result.chunks.forEach(function (chunk) {
        lookup.set(chunk.file, chunk);
    });
    var css_map = new Map();
    client_result.css_files.forEach(function (css_module) {
        css_map.set(css_module.id, css_module.code);
    });
    var chunks_with_css = new Set();
    // concatenate and emit CSS
    client_result.chunks.forEach(function (chunk) {
        var css_modules = chunk.modules.filter(function (m) { return css_map.has(m); });
        if (!css_modules.length)
            return;
        var css = get_css_from_modules(css_modules, css_map, asset_dir);
        var code = css.code, map = css.map;
        var output_file_name = chunk.file.replace(/\.js$/, '.css');
        map.file = output_file_name;
        if (sourcemap === true) {
            fs.writeFileSync(asset_dir + "/" + output_file_name + ".map", JSON.stringify(map, null, '  '));
            code += "\n/*# sourceMappingURL=" + output_file_name + ".map */";
        }
        if (sourcemap === 'inline') {
            var base64 = Buffer.from(JSON.stringify(map), 'utf8').toString('base64');
            code += "\n/*# sourceMappingURL=" + inline_sourcemap_header + base64 + " */";
        }
        fs.writeFileSync(asset_dir + "/" + output_file_name, code);
        chunks_with_css.add(chunk);
    });
    var entry = path.resolve(dirs.src, 'client.js');
    var entry_chunk = client_result.chunks.find(function (chunk) { return chunk.modules.indexOf(entry) !== -1; });
    var entry_chunk_dependencies = new Set([entry_chunk]);
    var entry_css_modules = [];
    // recursively find the chunks this component depends on
    entry_chunk_dependencies.forEach(function (chunk) {
        if (!chunk)
            return; // TODO why does this happen?
        chunk.imports.forEach(function (file) {
            entry_chunk_dependencies.add(lookup.get(file));
        });
        if (chunks_with_css.has(chunk)) {
            chunk.modules.forEach(function (file) {
                unclaimed.delete(file);
                if (css_map.has(file)) {
                    entry_css_modules.push(file);
                }
            });
        }
    });
    // figure out which (css-having) chunks each component depends on
    components.forEach(function (component) {
        var resolved = _commonjsHelpers.normalize_path(path.resolve(dirs.routes, component.file));
        var chunk = client_result.chunks.find(function (chunk) { return chunk.modules.indexOf(resolved) !== -1; });
        if (!chunk) {
            // this should never happen!
            throw new Error("Could not find chunk that owns " + component.file);
        }
        var chunk_dependencies = new Set([chunk]);
        var css_dependencies = [];
        // recursively find the chunks this component depends on
        chunk_dependencies.forEach(function (chunk) {
            if (!chunk)
                return; // TODO why does this happen?
            chunk.imports.forEach(function (file) {
                chunk_dependencies.add(lookup.get(file));
            });
            if (chunks_with_css.has(chunk)) {
                css_dependencies.push(chunk.file.replace(/\.js$/, '.css'));
                chunk.modules.forEach(function (file) {
                    unclaimed.delete(file);
                });
            }
        });
        result.chunks[component.file] = css_dependencies;
    });
    fs.readdirSync(asset_dir).forEach(function (file) {
        if (!file.endsWith('.js') || fs.statSync(asset_dir + "/" + file).isDirectory())
            return;
        var source = fs.readFileSync(asset_dir + "/" + file, 'utf-8');
        var replaced = source.replace(/(\\?["'])__SAPPER_CSS_PLACEHOLDER:([^"']+?)__\1/g, function (m, quotes, route) {
            var replacement = JSON.stringify(process.env.SAPPER_LEGACY_BUILD && result.chunks[route] ?
                result.chunks[route].map(function (_) { return "legacy/" + _; }) :
                result.chunks[route]);
            // If the quotation marks are escaped, then
            // the source code is in a string literal
            // (e.g., source maps) rather than raw
            // JavaScript source. We need to stringify
            // again and then remove the extra quotation
            // marks so that replacement is correct.
            if (quotes[0] === '\\') {
                replacement = JSON.stringify(replacement);
                replacement = replacement.substring(1, replacement.length - 1);
            }
            return replacement;
        });
        fs.writeFileSync(asset_dir + "/" + file, replaced);
    });
    unclaimed.forEach(function (file) {
        entry_css_modules.push(file);
    });
    var leftover = get_css_from_modules(entry_css_modules, css_map, asset_dir);
    if (leftover) {
        var code = leftover.code, map = leftover.map;
        var main_hash = hash(code);
        var output_file_name = "main." + main_hash + ".css";
        map.file = output_file_name;
        if (sourcemap === true) {
            fs.writeFileSync(asset_dir + "/" + output_file_name + ".map", JSON.stringify(map, null, '  '));
            code += "\n/*# sourceMappingURL=client/" + output_file_name + ".map */";
        }
        if (sourcemap === 'inline') {
            var base64 = Buffer.from(JSON.stringify(map), 'utf8').toString('base64');
            code += "\n/*# sourceMappingURL=" + inline_sourcemap_header + base64 + " */";
        }
        fs.writeFileSync(asset_dir + "/" + output_file_name, code);
        result.main = output_file_name;
    }
    return result;
}

var version = "1.0.1";

var RollupResult = /** @class */ (function () {
    function RollupResult(duration, compiler, sourcemap) {
        var _this = this;
        this.duration = duration;
        this.sourcemap = sourcemap;
        this.errors = compiler.errors.map(munge_warning_or_error);
        this.warnings = compiler.warnings.map(munge_warning_or_error);
        this.chunks = compiler.chunks.map(function (chunk) { return ({
            file: chunk.fileName,
            imports: chunk.imports.filter(Boolean),
            modules: Object.keys(chunk.modules).map(function (m) { return _commonjsHelpers.normalize_path(m); })
        }); });
        this.css_files = compiler.css_files;
        this.assets = {};
        if (typeof compiler.input === 'string') {
            compiler.chunks.forEach(function (chunk) {
                if (compiler.input in chunk.modules) {
                    _this.assets.main = chunk.fileName;
                }
            });
        }
        else {
            var _loop_1 = function (name_1) {
                var file = compiler.input[name_1];
                var chunk = compiler.chunks.find(function (chunk) { return file in chunk.modules; });
                if (chunk)
                    this_1.assets[name_1] = chunk.fileName;
            };
            var this_1 = this;
            for (var name_1 in compiler.input) {
                _loop_1(name_1);
            }
        }
        this.dependencies = transitiveDeps(compiler.chunks);
        this.summary = compiler.chunks.map(function (chunk) {
            var size_color = chunk.code.length > 150000 ? _commonjsHelpers.$.bold().red : chunk.code.length > 50000 ? _commonjsHelpers.$.bold().yellow : _commonjsHelpers.$.bold().white;
            var size_label = _commonjsHelpers.left_pad(index.prettyBytes(chunk.code.length), 10);
            var lines = [size_color(size_label + " " + chunk.fileName)];
            var deps = Object.keys(chunk.modules)
                .map(function (file) {
                return {
                    file: path.relative(process.cwd(), file),
                    size: chunk.modules[file].renderedLength
                };
            })
                .filter(function (dep) { return dep.size > 0; })
                .sort(function (a, b) { return b.size - a.size; });
            var total_unminified = deps.reduce(function (t, d) { return t + d.size; }, 0);
            deps.forEach(function (dep, i) {
                var c = i === deps.length - 1 ? '└' : '│';
                var line = "           " + c + " " + dep.file;
                if (deps.length > 1) {
                    var p = (100 * dep.size / total_unminified).toFixed(1);
                    line += " (" + p + "%)";
                }
                lines.push(_commonjsHelpers.$.gray(line));
            });
            return lines.join('\n');
        }).join('\n');
    }
    RollupResult.prototype.to_json = function (manifest_data, dirs) {
        var dependencies = {};
        Object.entries(this.dependencies).forEach(function (_a) {
            var key = _a[0], value = _a[1];
            dependencies[path.relative(dirs.routes, key)] = value;
        });
        return {
            bundler: 'rollup',
            shimport: version,
            assets: this.assets,
            dependencies: dependencies,
            // TODO extract_css has side-effects that don't belong in a method called to_json
            css: extract_css(this, manifest_data.components, dirs, this.sourcemap)
        };
    };
    RollupResult.prototype.print = function () {
        var blocks = this.warnings.map(function (warning) {
            return warning.file
                ? "> " + _commonjsHelpers.$.bold(warning.file) + "\n" + warning.message
                : "> " + warning.message;
        });
        blocks.push(this.summary);
        return blocks.join('\n\n');
    };
    return RollupResult;
}());
function munge_warning_or_error(warning_or_error) {
    return {
        file: warning_or_error.filename,
        message: [warning_or_error.message, warning_or_error.frame].filter(Boolean).join('\n')
    };
}

var stderr = console.error.bind(console);
var rollup;
var RollupCompiler = /** @class */ (function () {
    function RollupCompiler(config) {
        this._ = this.get_config(config);
        this.input = null;
        this.warnings = [];
        this.errors = [];
        this.chunks = [];
        this.css_files = [];
    }
    RollupCompiler.prototype.get_config = function (mod) {
        return _commonjsHelpers.__awaiter(this, void 0, void 0, function () {
            var onwarn;
            var _this = this;
            return _commonjsHelpers.__generator(this, function (_a) {
                // TODO this is hacky, and doesn't need to apply to all three compilers
                (mod.plugins || (mod.plugins = [])).push({
                    name: 'sapper-internal',
                    options: function (opts) {
                        _this.input = opts.input;
                    },
                    renderChunk: function (code, chunk) {
                        _this.chunks.push(chunk);
                    },
                    transform: function (code, id) {
                        if (/\.css$/.test(id)) {
                            _this.css_files.push({ id: id, code: code });
                            return { code: '', moduleSideEffects: 'no-treeshake' };
                        }
                    }
                });
                onwarn = mod.onwarn || (function (warning, handler) {
                    handler(warning);
                });
                mod.onwarn = function (warning) {
                    onwarn(warning, function (warning) {
                        _this.warnings.push(warning);
                    });
                };
                return [2 /*return*/, mod];
            });
        });
    };
    RollupCompiler.prototype.oninvalid = function (cb) {
        this._oninvalid = cb;
    };
    RollupCompiler.prototype.compile = function () {
        return _commonjsHelpers.__awaiter(this, void 0, void 0, function () {
            var config, sourcemap, start, bundle, err_1;
            return _commonjsHelpers.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._];
                    case 1:
                        config = _a.sent();
                        sourcemap = config.output.sourcemap;
                        start = Date.now();
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 5, , 6]);
                        return [4 /*yield*/, rollup.rollup(config)];
                    case 3:
                        bundle = _a.sent();
                        return [4 /*yield*/, bundle.write(config.output)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/, new RollupResult(Date.now() - start, this, sourcemap)];
                    case 5:
                        err_1 = _a.sent();
                        // flush warnings
                        stderr(new RollupResult(Date.now() - start, this, sourcemap).print());
                        handleError(err_1);
                        return [3 /*break*/, 6];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    RollupCompiler.prototype.watch = function (cb) {
        return _commonjsHelpers.__awaiter(this, void 0, void 0, function () {
            var config, sourcemap, watcher;
            var _this = this;
            return _commonjsHelpers.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._];
                    case 1:
                        config = _a.sent();
                        sourcemap = config.output.sourcemap;
                        watcher = rollup.watch(config);
                        watcher.on('change', function (id) {
                            _this.chunks = [];
                            _this.warnings = [];
                            _this.errors = [];
                            _this._oninvalid(id);
                        });
                        watcher.on('event', function (event) {
                            switch (event.code) {
                                case 'FATAL':
                                    // TODO kill the process?
                                    if (event.error.filename) {
                                        // TODO this is a bit messy. Also, can
                                        // Rollup emit other kinds of error?
                                        event.error.message = [
                                            "Failed to build \u2014 error in " + event.error.filename + ": " + event.error.message,
                                            event.error.frame
                                        ].filter(Boolean).join('\n');
                                    }
                                    cb(event.error);
                                    break;
                                case 'ERROR':
                                    _this.errors.push(event.error);
                                    cb(null, new RollupResult(Date.now() - _this._start, _this, sourcemap));
                                    break;
                                case 'START':
                                case 'END':
                                    // TODO is there anything to do with this info?
                                    break;
                                case 'BUNDLE_START':
                                    _this._start = Date.now();
                                    break;
                                case 'BUNDLE_END':
                                    cb(null, new RollupResult(Date.now() - _this._start, _this, sourcemap));
                                    break;
                                default:
                                    console.log("Unexpected event " + event.code);
                            }
                        });
                        return [2 /*return*/];
                }
            });
        });
    };
    RollupCompiler.load_config = function (cwd) {
        return _commonjsHelpers.__awaiter(this, void 0, void 0, function () {
            var input, bundle, code, defaultLoader, config;
            return _commonjsHelpers.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!rollup)
                            rollup = requireRelative_1('rollup', cwd);
                        input = path.resolve(cwd, 'rollup.config.js');
                        return [4 /*yield*/, rollup.rollup({
                                input: input,
                                inlineDynamicImports: true,
                                external: function (id) {
                                    return (id[0] !== '.' && !path.isAbsolute(id)) || id.slice(-5, id.length) === '.json';
                                }
                            })];
                    case 1:
                        bundle = _a.sent();
                        return [4 /*yield*/, bundle.generate({
                                exports: 'named',
                                format: 'cjs'
                            })];
                    case 2:
                        code = (_a.sent()).output[0].code;
                        defaultLoader = require.extensions['.js'];
                        require.extensions['.js'] = function (module, filename) {
                            if (filename === input) {
                                module._compile(code, filename);
                            }
                            else {
                                defaultLoader(module, filename);
                            }
                        };
                        config = require(input).default;
                        delete require.cache[input];
                        return [2 /*return*/, config];
                }
            });
        });
    };
    return RollupCompiler;
}());
// copied from https://github.com/rollup/rollup/blob/master/cli/logging.ts
// and updated so that it will compile here
function handleError(err, recover) {
    if (recover === void 0) { recover = false; }
    var description = err.message || err;
    if (err.name)
        description = err.name + ": " + description;
    var message = (err.plugin
        ? "(plugin " + (err).plugin + ") " + description
        : description) || err;
    stderr(_commonjsHelpers.$.bold().red("[!] " + _commonjsHelpers.$.bold(message.toString())));
    if (err.url) {
        stderr(_commonjsHelpers.$.cyan(err.url));
    }
    if (err.loc) {
        stderr((err.loc.file || err.id) + " (" + err.loc.line + ":" + err.loc.column + ")");
    }
    else if (err.id) {
        stderr(err.id);
    }
    if (err.frame) {
        stderr(_commonjsHelpers.$.dim(err.frame));
    }
    if (err.stack) {
        stderr(_commonjsHelpers.$.dim(err.stack));
    }
    stderr('');
    if (!recover)
        process.exit(1);
}

const { FORCE_COLOR, NODE_DISABLE_COLORS, TERM } = process.env;

const $ = {
	enabled: !NODE_DISABLE_COLORS && TERM !== 'dumb' && FORCE_COLOR !== '0',

	// modifiers
	reset: init(0, 0),
	bold: init(1, 22),
	dim: init(2, 22),
	italic: init(3, 23),
	underline: init(4, 24),
	inverse: init(7, 27),
	hidden: init(8, 28),
	strikethrough: init(9, 29),

	// colors
	black: init(30, 39),
	red: init(31, 39),
	green: init(32, 39),
	yellow: init(33, 39),
	blue: init(34, 39),
	magenta: init(35, 39),
	cyan: init(36, 39),
	white: init(37, 39),
	gray: init(90, 39),
	grey: init(90, 39),

	// background colors
	bgBlack: init(40, 49),
	bgRed: init(41, 49),
	bgGreen: init(42, 49),
	bgYellow: init(43, 49),
	bgBlue: init(44, 49),
	bgMagenta: init(45, 49),
	bgCyan: init(46, 49),
	bgWhite: init(47, 49)
};

function run(arr, str) {
	let i=0, tmp, beg='', end='';
	for (; i < arr.length; i++) {
		tmp = arr[i];
		beg += tmp.open;
		end += tmp.close;
		if (str.includes(tmp.close)) {
			str = str.replace(tmp.rgx, tmp.close + tmp.open);
		}
	}
	return beg + str + end;
}

function chain(has, keys) {
	let ctx = { has, keys };

	ctx.reset = $.reset.bind(ctx);
	ctx.bold = $.bold.bind(ctx);
	ctx.dim = $.dim.bind(ctx);
	ctx.italic = $.italic.bind(ctx);
	ctx.underline = $.underline.bind(ctx);
	ctx.inverse = $.inverse.bind(ctx);
	ctx.hidden = $.hidden.bind(ctx);
	ctx.strikethrough = $.strikethrough.bind(ctx);

	ctx.black = $.black.bind(ctx);
	ctx.red = $.red.bind(ctx);
	ctx.green = $.green.bind(ctx);
	ctx.yellow = $.yellow.bind(ctx);
	ctx.blue = $.blue.bind(ctx);
	ctx.magenta = $.magenta.bind(ctx);
	ctx.cyan = $.cyan.bind(ctx);
	ctx.white = $.white.bind(ctx);
	ctx.gray = $.gray.bind(ctx);
	ctx.grey = $.grey.bind(ctx);

	ctx.bgBlack = $.bgBlack.bind(ctx);
	ctx.bgRed = $.bgRed.bind(ctx);
	ctx.bgGreen = $.bgGreen.bind(ctx);
	ctx.bgYellow = $.bgYellow.bind(ctx);
	ctx.bgBlue = $.bgBlue.bind(ctx);
	ctx.bgMagenta = $.bgMagenta.bind(ctx);
	ctx.bgCyan = $.bgCyan.bind(ctx);
	ctx.bgWhite = $.bgWhite.bind(ctx);

	return ctx;
}

function init(open, close) {
	let blk = {
		open: `\x1b[${open}m`,
		close: `\x1b[${close}m`,
		rgx: new RegExp(`\\x1b\\[${close}m`, 'g')
	};
	return function (txt) {
		if (this !== void 0 && this.has !== void 0) {
			this.has.includes(open) || (this.has.push(open),this.keys.push(blk));
			return txt === void 0 ? this : $.enabled ? run(this.keys, txt+'') : txt+'';
		}
		return txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt+'') : txt+'';
	};
}

var kleur = $;

/**
 * This has been adapted from `create-react-app`, authored by Facebook, Inc.
 * see: https://github.com/facebookincubator/create-react-app/tree/master/packages/react-dev-utils
 */



const errorLabel = 'Syntax error:';
const isLikelyASyntaxError = str => str.includes(errorLabel);

const exportRegex = /\s*(.+?)\s*(")?export '(.+?)' was not found in '(.+?)'/;
const stackRegex = /^\s*at\s((?!webpack:).)*:\d+:\d+[\s\)]*(\n|$)/gm;

function formatMessage(message, isError) {
	// Workaround to accommodate Webpack v5
	// It gives us an Object now, not a string...
	// Objects not identical; details > stack > message
	if (typeof message === 'object') {
		message = message.details || message.stack || message.message;
	}

	let lines = message.split('\n');

	if (lines.length > 2 && lines[1] === '') {
		lines.splice(1, 1); // Remove extra newline.
	}

	// Remove loader notation from filenames:
	//   `./~/css-loader!./src/App.css` ~~> `./src/App.css`
	if (lines[0].lastIndexOf('!') !== -1) {
		lines[0] = lines[0].substr(lines[0].lastIndexOf('!') + 1);
	}

	// Remove useless `entry` filename stack details
	lines = lines.filter(line => line.indexOf(' @ ') !== 0);

	// 0 ~> filename; 1 ~> main err msg
	if (!lines[0] || !lines[1]) {
		return lines.join('\n');
	}

	// Cleans up verbose "module not found" messages for files and packages.
	if (lines[1].startsWith('Module not found: ')) {
		lines = [
			lines[0],
			lines[1] // "Module not found: " is enough detail
				.replace("Cannot resolve 'file' or 'directory' ", '')
				.replace('Cannot resolve module ', '')
				.replace('Error: ', '')
				.replace('[CaseSensitivePathsPlugin] ', '')
		];
	}

	// Cleans up syntax error messages.
	if (lines[1].startsWith('Module build failed: ')) {
		lines[1] = lines[1].replace('Module build failed: SyntaxError:', errorLabel);
	}

	if (lines[1].match(exportRegex)) {
		lines[1] = lines[1].replace(exportRegex, "$1 '$4' does not contain an export named '$3'.");
	}

	lines[0] = kleur.inverse(lines[0]);

	// Reassemble & Strip internal tracing, except `webpack:` -- (create-react-app/pull/1050)
	return lines.join('\n').replace(stackRegex, '').trim();
}

var webpackFormatMessages = function (stats) {
	const json = stats.toJson({}, true);

	const result = {
		errors: json.errors.map(msg => formatMessage(msg)),
		warnings: json.warnings.map(msg => formatMessage(msg))
	};

	// Only show syntax errors if we have them
	if (result.errors.some(isLikelyASyntaxError)) {
		result.errors = result.errors.filter(isLikelyASyntaxError);
	}

	// First error is usually it; others usually the same
	if (result.errors.length > 1) {
		result.errors.length = 1;
	}

	return result;
};

var formatMessage_1 = formatMessage;
webpackFormatMessages.formatMessage = formatMessage_1;

var locPattern = /\((\d+):(\d+)\)$/;
function munge_warning_or_error$1(message) {
    // TODO this is all a bit rube goldberg...
    var lines = message.split('\n');
    var file = lines.shift()
        // eslint-disable-next-line
        .replace('[7m', '') // careful — there is a special character at the beginning of this string
        .replace('[27m', '')
        .replace('./', '');
    var line = null;
    var column = null;
    var match = locPattern.exec(lines[0]);
    if (match) {
        lines[0] = lines[0].replace(locPattern, '');
        line = +match[1];
        column = +match[2];
    }
    return {
        file: file,
        message: lines.join('\n')
    };
}
var WebpackResult = /** @class */ (function () {
    function WebpackResult(stats) {
        this.stats = stats;
        var info = stats.toJson();
        var messages = webpackFormatMessages(stats);
        this.errors = messages.errors.map(munge_warning_or_error$1);
        this.warnings = messages.warnings.map(munge_warning_or_error$1);
        this.duration = info.time;
        this.chunks = info.assets.map(function (chunk) { return ({ file: chunk.name }); });
        this.assets = info.assetsByChunkName;
    }
    WebpackResult.prototype.to_json = function (manifest_data, dirs) {
        var _this = this;
        var extract_css = function (assets) {
            assets = Array.isArray(assets) ? assets : [assets];
            return assets.find(function (asset) { return /\.css$/.test(asset); });
        };
        return {
            bundler: 'webpack',
            shimport: null,
            assets: this.assets,
            css: {
                main: extract_css(this.assets.main),
                chunks: manifest_data.components
                    .reduce(function (chunks, component) {
                    var css_dependencies = [];
                    var css = extract_css(_this.assets[component.name]);
                    if (css)
                        css_dependencies.push(css);
                    chunks[component.file] = css_dependencies;
                    return chunks;
                }, {})
            }
        };
    };
    WebpackResult.prototype.print = function () {
        return this.stats.toString({ colors: true });
    };
    return WebpackResult;
}());

var webpack;
var WebpackCompiler = /** @class */ (function () {
    function WebpackCompiler(config) {
        if (!webpack)
            webpack = requireRelative_1('webpack', process.cwd());
        this._ = webpack(config);
    }
    WebpackCompiler.prototype.oninvalid = function (cb) {
        this._.hooks.invalid.tap('sapper', cb);
    };
    WebpackCompiler.prototype.compile = function () {
        var _this = this;
        return new Promise(function (fulfil, reject) {
            _this._.run(function (err, stats) {
                if (err) {
                    reject(err);
                    process.exit(1);
                }
                var result = new WebpackResult(stats);
                if (result.errors.length) {
                    console.error(stats.toString({ colors: true }));
                    reject(new Error("Encountered errors while building app"));
                }
                else {
                    fulfil(result);
                }
            });
        });
    };
    WebpackCompiler.prototype.watch = function (cb) {
        this._.watch({}, function (err, stats) {
            cb(err, stats && new WebpackResult(stats));
        });
    };
    return WebpackCompiler;
}());

function create_compilers(bundler, cwd, src, dest, dev) {
    return _commonjsHelpers.__awaiter(this, void 0, void 0, function () {
        var config, config;
        return _commonjsHelpers.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    env.set_dev(dev);
                    env.set_src(src);
                    env.set_dest(dest);
                    if (!(bundler === 'rollup')) return [3 /*break*/, 2];
                    return [4 /*yield*/, RollupCompiler.load_config(cwd)];
                case 1:
                    config = _a.sent();
                    validate_config(config, 'rollup');
                    normalize_rollup_config(config.client);
                    normalize_rollup_config(config.server);
                    if (config.serviceworker) {
                        normalize_rollup_config(config.serviceworker);
                    }
                    return [2 /*return*/, {
                            client: new RollupCompiler(config.client),
                            server: new RollupCompiler(config.server),
                            serviceworker: config.serviceworker && new RollupCompiler(config.serviceworker)
                        }];
                case 2:
                    if (bundler === 'webpack') {
                        config = require(path.resolve(cwd, 'webpack.config.js'));
                        validate_config(config, 'webpack');
                        return [2 /*return*/, {
                                client: new WebpackCompiler(config.client),
                                server: new WebpackCompiler(config.server),
                                serviceworker: config.serviceworker && new WebpackCompiler(config.serviceworker)
                            }];
                    }
                    // this shouldn't be possible...
                    throw new Error("Invalid bundler option '" + bundler + "'");
            }
        });
    });
}
function validate_config(config, bundler) {
    if (!config.client || !config.server) {
        throw new Error(bundler + ".config.js must export a { client, server, serviceworker? } object");
    }
}
function normalize_rollup_config(config) {
    if (typeof config.input === 'string') {
        config.input = path.normalize(config.input);
    }
    else {
        for (var name_1 in config.input) {
            config.input[name_1] = path.normalize(config.input[name_1]);
        }
    }
}

function create_manifest_data(cwd, extensions) {
    if (extensions === void 0) { extensions = '.svelte .html'; }
    var component_extensions = extensions.split(' ');
    // TODO remove in a future version
    if (!fs.existsSync(cwd)) {
        throw new Error("As of Sapper 0.21, the routes/ directory should become src/routes/");
    }
    function find_layout(file_name, component_name, dir) {
        if (dir === void 0) { dir = ''; }
        var ext = component_extensions.find(function (ext) { return fs.existsSync(path.join(cwd, dir, "" + file_name + ext)); });
        var file = _commonjsHelpers.posixify(path.join(dir, "" + file_name + ext));
        return ext
            ? {
                name: component_name,
                file: file
            }
            : null;
    }
    var components = [];
    var pages = [];
    var server_routes = [];
    var default_layout = {
        default: true,
        type: 'layout',
        name: '_default_layout',
        file: null
    };
    var default_error = {
        default: true,
        type: 'error',
        name: '_default_error',
        file: null
    };
    function walk(dir, parent_segments, parent_params, stack) {
        var items = fs.readdirSync(dir)
            .map(function (basename) {
            var resolved = path.join(dir, basename);
            var file = path.relative(cwd, resolved);
            var is_dir = fs.statSync(resolved).isDirectory();
            var ext = path.extname(basename);
            if (basename[0] === '_')
                return null;
            if (basename[0] === '.' && basename !== '.well-known')
                return null;
            if (!is_dir && !/^\.[a-z]+$/i.test(ext))
                return null; // filter out tmp files etc
            var segment = is_dir
                ? basename
                : basename.slice(0, -ext.length);
            if (/\]\[/.test(segment)) {
                throw new Error("Invalid route " + file + " \u2014 parameters must be separated");
            }
            var parts = get_parts(segment);
            var is_index = is_dir ? false : basename.startsWith('index.');
            var is_page = component_extensions.indexOf(ext) !== -1;
            var route_suffix = basename.slice(basename.indexOf('.'), -ext.length);
            parts.forEach(function (part) {
                if (part.qualifier && /[()?:]/.test(part.qualifier.slice(1, -1))) {
                    throw new Error("Invalid route " + file + " \u2014 cannot use (, ), ? or : in route qualifiers");
                }
            });
            return {
                basename: basename,
                ext: ext,
                parts: parts,
                file: _commonjsHelpers.posixify(file),
                is_dir: is_dir,
                is_index: is_index,
                is_page: is_page,
                route_suffix: route_suffix
            };
        })
            .filter(Boolean)
            .sort(comparator);
        items.forEach(function (item) {
            var segments = parent_segments.slice();
            if (item.is_index) {
                if (item.route_suffix) {
                    if (segments.length > 0) {
                        var last_segment = segments[segments.length - 1].slice();
                        var last_part = last_segment[last_segment.length - 1];
                        if (last_part.dynamic) {
                            last_segment.push({ dynamic: false, content: item.route_suffix });
                        }
                        else {
                            last_segment[last_segment.length - 1] = {
                                dynamic: false,
                                content: "" + last_part.content + item.route_suffix
                            };
                        }
                        segments[segments.length - 1] = last_segment;
                    }
                    else {
                        segments.push(item.parts);
                    }
                }
            }
            else {
                segments.push(item.parts);
            }
            var params = parent_params.slice();
            params.push.apply(params, item.parts.filter(function (p) { return p.dynamic; }).map(function (p) { return p.content; }));
            if (item.is_dir) {
                var component = find_layout('_layout', get_slug(item.file) + "__layout", item.file);
                if (component)
                    components.push(component);
                walk(path.join(dir, item.basename), segments, params, component
                    ? stack.concat({ component: component, params: params })
                    : stack.concat(null));
            }
            else if (item.is_page) {
                var component = {
                    name: get_slug(item.file),
                    file: item.file
                };
                components.push(component);
                var parts = (item.is_index && stack[stack.length - 1] === null)
                    ? stack.slice(0, -1).concat({ component: component, params: params })
                    : stack.concat({ component: component, params: params });
                pages.push({
                    pattern: get_pattern(segments, true),
                    parts: parts
                });
            }
            else {
                server_routes.push({
                    name: "route_" + get_slug(item.file),
                    pattern: get_pattern(segments, !item.route_suffix),
                    file: item.file,
                    params: params
                });
            }
        });
    }
    var root = find_layout('_layout', 'main') || default_layout;
    var error = find_layout('_error', 'error') || default_error;
    walk(cwd, [], [], []);
    // check for clashes
    var seen_pages = new Map();
    pages.forEach(function (page) {
        var pattern = page.pattern.toString();
        if (seen_pages.has(pattern)) {
            var file = page.parts.pop().component.file;
            var other_page = seen_pages.get(pattern);
            var other_file = other_page.parts.pop().component.file;
            throw new Error("The " + other_file + " and " + file + " pages clash");
        }
        seen_pages.set(pattern, page);
    });
    var seen_routes = new Map();
    server_routes.forEach(function (route) {
        var pattern = route.pattern.toString();
        if (seen_routes.has(pattern)) {
            var other_route = seen_routes.get(pattern);
            throw new Error("The " + other_route.file + " and " + route.file + " routes clash");
        }
        seen_routes.set(pattern, route);
    });
    return {
        root: root,
        error: error,
        components: components,
        pages: pages,
        server_routes: server_routes
    };
}
function is_spread(path) {
    var spread_pattern = /\[\.{3}/g;
    return spread_pattern.test(path);
}
function comparator(a, b) {
    if (a.is_index !== b.is_index) {
        if (a.is_index)
            return is_spread(a.file) ? 1 : -1;
        return is_spread(b.file) ? -1 : 1;
    }
    var max = Math.max(a.parts.length, b.parts.length);
    for (var i = 0; i < max; i += 1) {
        var a_sub_part = a.parts[i];
        var b_sub_part = b.parts[i];
        if (!a_sub_part)
            return 1; // b is more specific, so goes first
        if (!b_sub_part)
            return -1;
        // if spread && index, order later
        if (a_sub_part.spread && b_sub_part.spread) {
            return a.is_index ? 1 : -1;
        }
        // If one is ...spread order it later
        if (a_sub_part.spread !== b_sub_part.spread)
            return a_sub_part.spread ? 1 : -1;
        if (a_sub_part.dynamic !== b_sub_part.dynamic) {
            return a_sub_part.dynamic ? 1 : -1;
        }
        if (!a_sub_part.dynamic && a_sub_part.content !== b_sub_part.content) {
            return ((b_sub_part.content.length - a_sub_part.content.length) ||
                (a_sub_part.content < b_sub_part.content ? -1 : 1));
        }
        // If both parts dynamic, check for regexp patterns
        if (a_sub_part.dynamic && b_sub_part.dynamic) {
            var regexp_pattern = /\((.*?)\)/;
            var a_match = regexp_pattern.exec(a_sub_part.content);
            var b_match = regexp_pattern.exec(b_sub_part.content);
            if (!a_match && b_match) {
                return 1; // No regexp, so less specific than b
            }
            if (!b_match && a_match) {
                return -1;
            }
            if (a_match && b_match && a_match[1] !== b_match[1]) {
                return b_match[1].length - a_match[1].length;
            }
        }
    }
}
function get_parts(part) {
    return part.split(/\[(.+?\(.+?\)|.+?)\]/)
        .map(function (str, i) {
        if (!str)
            return null;
        var dynamic = i % 2 === 1;
        var _a = dynamic
            ? /([^(]+)(\(.+\))?$/.exec(str)
            : [null, str, null], content = _a[1], qualifier = _a[2];
        return {
            content: content,
            dynamic: dynamic,
            spread: /^\.{3}.+$/.test(content),
            qualifier: qualifier
        };
    })
        .filter(Boolean);
}
function get_slug(file) {
    var name = file
        .replace(/[\\/]index/, '')
        .replace(/[/\\]/g, '_')
        .replace(/\.\w+$/, '')
        .replace(/\[([^(]+)(?:\([^(]+\))?\]/, '$$$1')
        .replace(/[^a-zA-Z0-9_$]/g, function (c) {
        return c === '.' ? '_' : "$" + c.charCodeAt(0);
    });
    if (_commonjsHelpers.reserved_words.has(name))
        name += '_';
    return name;
}
function get_pattern(segments, add_trailing_slash) {
    var path = segments.map(function (segment) {
        return segment.map(function (part) {
            return part.dynamic
                ? part.qualifier || (part.spread ? '(.+)' : '([^/]+?)')
                : encodeURI(part.content.normalize())
                    .replace(/\?/g, '%3F')
                    .replace(/#/g, '%23')
                    .replace(/%5B/g, '[')
                    .replace(/%5D/g, ']')
                    .replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }).join('');
    }).join('\\/');
    var trailing = add_trailing_slash && segments.length ? '\\/?$' : '$';
    return new RegExp("^\\/" + path + trailing);
}

exports.create_app = create_app;
exports.create_compilers = create_compilers;
exports.create_manifest_data = create_manifest_data;
exports.create_serviceworker_manifest = create_serviceworker_manifest;
exports.version = version;
//# sourceMappingURL=create_manifest_data.js.map
